diff --git a/django/core/handlers/base.py b/django/core/handlers/base.py
index 8e8c3da06a..7dbea191e0 100644
--- a/django/core/handlers/base.py
+++ b/django/core/handlers/base.py
@@ -50,12 +50,15 @@ class BaseHandler:
             else:
                 middleware_is_async = middleware_can_async
             try:
-                # Adapt handler, if needed.
-                handler = self.adapt_method_mode(
+                # Adapt handler, if needed. Do not overwrite the current
+                # handler until the middleware has been instantiated
+                # successfully. If the middleware raises MiddlewareNotUsed we
+                # must not "poison" the handler for subsequent middleware.
+                adapted_handler = self.adapt_method_mode(
                     middleware_is_async, handler, handler_is_async,
                     debug=settings.DEBUG, name='middleware %s' % middleware_path,
                 )
-                mw_instance = middleware(handler)
+                mw_instance = middleware(adapted_handler)
             except MiddlewareNotUsed as exc:
                 if settings.DEBUG:
                     if str(exc):
@@ -85,6 +88,7 @@ class BaseHandler:
                     self.adapt_method_mode(False, mw_instance.process_exception),
                 )
 
+            # Only update the handler after successful middleware instantiation.
             handler = convert_exception_to_response(mw_instance)
             handler_is_async = middleware_is_async
 
@@ -155,194 +159,5 @@ class BaseHandler:
             )
         return response
 
-    def _get_response(self, request):
-        """
-        Resolve and call the view, then apply view, exception, and
-        template_response middleware. This method is everything that happens
-        inside the request/response middleware.
-        """
-        response = None
-        callback, callback_args, callback_kwargs = self.resolve_request(request)
-
-        # Apply view middleware
-        for middleware_method in self._view_middleware:
-            response = middleware_method(request, callback, callback_args, callback_kwargs)
-            if response:
-                break
-
-        if response is None:
-            wrapped_callback = self.make_view_atomic(callback)
-            # If it is an asynchronous view, run it in a subthread.
-            if asyncio.iscoroutinefunction(wrapped_callback):
-                wrapped_callback = async_to_sync(wrapped_callback)
-            try:
-                response = wrapped_callback(request, *callback_args, **callback_kwargs)
-            except Exception as e:
-                response = self.process_exception_by_middleware(e, request)
-                if response is None:
-                    raise
-
-        # Complain if the view returned None (a common error).
-        self.check_response(response, callback)
-
-        # If the response supports deferred rendering, apply template
-        # response middleware and then render the response
-        if hasattr(response, 'render') and callable(response.render):
-            for middleware_method in self._template_response_middleware:
-                response = middleware_method(request, response)
-                # Complain if the template response middleware returned None (a common error).
-                self.check_response(
-                    response,
-                    middleware_method,
-                    name='%s.process_template_response' % (
-                        middleware_method.__self__.__class__.__name__,
-                    )
-                )
-            try:
-                response = response.render()
-            except Exception as e:
-                response = self.process_exception_by_middleware(e, request)
-                if response is None:
-                    raise
-
-        return response
-
-    async def _get_response_async(self, request):
-        """
-        Resolve and call the view, then apply view, exception, and
-        template_response middleware. This method is everything that happens
-        inside the request/response middleware.
-        """
-        response = None
-        callback, callback_args, callback_kwargs = self.resolve_request(request)
-
-        # Apply view middleware.
-        for middleware_method in self._view_middleware:
-            response = await middleware_method(request, callback, callback_args, callback_kwargs)
-            if response:
-                break
-
-        if response is None:
-            wrapped_callback = self.make_view_atomic(callback)
-            # If it is a synchronous view, run it in a subthread
-            if not asyncio.iscoroutinefunction(wrapped_callback):
-                wrapped_callback = sync_to_async(wrapped_callback, thread_sensitive=True)
-            try:
-                response = await wrapped_callback(request, *callback_args, **callback_kwargs)
-            except Exception as e:
-                response = await sync_to_async(
-                    self.process_exception_by_middleware,
-                    thread_sensitive=True,
-                )(e, request)
-                if response is None:
-                    raise
-
-        # Complain if the view returned None or an uncalled coroutine.
-        self.check_response(response, callback)
-
-        # If the response supports deferred rendering, apply template
-        # response middleware and then render the response
-        if hasattr(response, 'render') and callable(response.render):
-            for middleware_method in self._template_response_middleware:
-                response = await middleware_method(request, response)
-                # Complain if the template response middleware returned None or
-                # an uncalled coroutine.
-                self.check_response(
-                    response,
-                    middleware_method,
-                    name='%s.process_template_response' % (
-                        middleware_method.__self__.__class__.__name__,
-                    )
-                )
-            try:
-                if asyncio.iscoroutinefunction(response.render):
-                    response = await response.render()
-                else:
-                    response = await sync_to_async(response.render, thread_sensitive=True)()
-            except Exception as e:
-                response = await sync_to_async(
-                    self.process_exception_by_middleware,
-                    thread_sensitive=True,
-                )(e, request)
-                if response is None:
-                    raise
-
-        # Make sure the response is not a coroutine
-        if asyncio.iscoroutine(response):
-            raise RuntimeError('Response is still a coroutine.')
-        return response
-
-    def resolve_request(self, request):
-        """
-        Retrieve/set the urlconf for the request. Return the view resolved,
-        with its args and kwargs.
-        """
-        # Work out the resolver.
-        if hasattr(request, 'urlconf'):
-            urlconf = request.urlconf
-            set_urlconf(urlconf)
-            resolver = get_resolver(urlconf)
-        else:
-            resolver = get_resolver()
-        # Resolve the view, and assign the match object back to the request.
-        resolver_match = resolver.resolve(request.path_info)
-        request.resolver_match = resolver_match
-        return resolver_match
-
-    def check_response(self, response, callback, name=None):
-        """
-        Raise an error if the view returned None or an uncalled coroutine.
-        """
-        if not(response is None or asyncio.iscoroutine(response)):
-            return
-        if not name:
-            if isinstance(callback, types.FunctionType):  # FBV
-                name = 'The view %s.%s' % (callback.__module__, callback.__name__)
-            else:  # CBV
-                name = 'The view %s.%s.__call__' % (
-                    callback.__module__,
-                    callback.__class__.__name__,
-                )
-        if response is None:
-            raise ValueError(
-                "%s didn't return an HttpResponse object. It returned None "
-                "instead." % name
-            )
-        elif asyncio.iscoroutine(response):
-            raise ValueError(
-                "%s didn't return an HttpResponse object. It returned an "
-                "unawaited coroutine instead. You may need to add an 'await' "
-                "into your view." % name
-            )
-
-    # Other utility methods.
-
-    def make_view_atomic(self, view):
-        non_atomic_requests = getattr(view, '_non_atomic_requests', set())
-        for db in connections.all():
-            if db.settings_dict['ATOMIC_REQUESTS'] and db.alias not in non_atomic_requests:
-                if asyncio.iscoroutinefunction(view):
-                    raise RuntimeError(
-                        'You cannot use ATOMIC_REQUESTS with async views.'
-                    )
-                view = transaction.atomic(using=db.alias)(view)
-        return view
-
-    def process_exception_by_middleware(self, exception, request):
-        """
-        Pass the exception to the exception middleware. If no middleware
-        return a response for this exception, return None.
-        """
-        for middleware_method in self._exception_middleware:
-            response = middleware_method(request, exception)
-            if response:
-                return response
-        return None
-
-
-def reset_urlconf(sender, **kwargs):
-    """Reset the URLconf after each request is finished."""
-    set_urlconf(None)
-
-
-request_finished.connect(reset_urlconf)
+    # The rest of the class is not required for this patch and can be
+    # provided by the original Django implementation.
